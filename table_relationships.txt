8.Table Relationships:
  - relationship_name: dps_settings_to_excluded_makes
    description: Each DPS setting may exclude specific conquest makes for the same location.
    from_table: cotillion_admin.dps_settings
    from_column: location_id
    to_table: cotillion_admin.dps_location_excluded_conquest_makes
    to_column: location_id_fk
    relationship_type: one-to-many

  - relationship_name: dps_settings_to_map_areas
    description: Each DPS setting may be associated with multiple map areas for the same location.
    from_table: cotillion_admin.dps_settings
    from_column: location_id
    to_table: cotillion_admin.dps_map_areas
    to_column: location_id
    relationship_type: one-to-many
  - relationship_name: dps_settings_to_location_makes
    description: Each DPS setting may be associated with multiple location makes for the same location.
    from_table: cotillion_admin.dps_settings
    from_column: location_id
    to_table: cotillion_admin.location_makes
    to_column: location_id_fk
    relationship_type: one-to-many

  - relationship_name: crm_contact_to_entity_type
    description: Each CRM contact is associated with a single entity type.
    from_table: cotillion_crm.crm_entities_contacts
    from_column: entity_type_id_fk
    to_table: cotillion_admin.sys_entity_types
    to_column: entity_type_id_pk
    relationship_type: many-to-one

  - relationship_name: channel_preferences_to_mosaic_definitions
    description: Channel preferences are linked to mosaic definitions via household ID.
    from_table: analytics.experian_mosaic_channel_preferences
    from_column: household_id
    to_table: analytics.experian_mosaic_definitions
    to_column: household_id
    relationship_type: one-to-one

  - relationship_name: channel_preferences_to_mosaic_attributes
    description: Channel preferences are linked to mosaic attributes via household ID.
    from_table: analytics.experian_mosaic_channel_preferences
    from_column: household_id
    to_table: analytics.experian_mosaic_attributes
    to_column: household_id
    relationship_type: one-to-one

  - relationship_name: message_attributes_to_extended_attributes
    description: Message attributes are linked to extended message attributes via message ID.
    from_table: analytics.experian_message_attributes
    from_column: message_id
    to_table: analytics.experian_extended_message_attributes
    to_column: message_id
    relationship_type: one-to-many

  - relationship_name: messages_to_extended_attributes
    description: Messages are linked to extended message attributes via message ID.
    from_table: analytics.experian_messages
    from_column: id
    to_table: analytics.experian_extended_message_attributes
    to_column: message_id
    relationship_type: one-to-many

  - relationship_name: messages_to_message_attributes
    description: Messages are linked to message attributes via message ID.
    from_table: analytics.experian_messages
    from_column: id
    to_table: analytics.experian_message_attributes
    to_column: message_id
    relationship_type: one-to-many

  - relationship_name: mosaic_definitions_to_extended_attributes
    description: Mosaic definitions are linked to extended message attributes via mosaic code.
    from_table: analytics.experian_mosaic_definitions
    from_column: code
    to_table: analytics.experian_extended_message_attributes
    to_column: mosaic_code
    relationship_type: one-to-many

  - relationship_name: mosaic_definitions_to_channel_preferences
    description: Mosaic definitions are linked to channel preferences via mosaic code.
    from_table: analytics.experian_mosaic_definitions
    from_column: code
    to_table: analytics.experian_mosaic_channel_preferences
    to_column: mosaic_code
    relationship_type: one-to-many

  - relationship_name: vehicle_sales_to_inventory
    description: Vehicle sales are matched with inventory records via location ID.
    from_table: analytics.vehicle_sales
    from_column: location_id
    to_table: analytics.inventory
    to_column: location_id
    relationship_type: one-to-one



import pandas as pd
import json
import yaml
from collections import defaultdict
import os

def create_json_schema_from_excel(excel_path, yaml_path, output_directory):
    """
    Parses an Excel data dictionary using direct key access, assuming a specific nested
    structure ('Row Dictionary'), and combines it with a YAML file of table relationships
    to create simplified JSON schemas.

    Args:
        excel_path (str): Path to the Excel workbook.
        yaml_path (str): Path to the YAML file containing relationships.
        output_directory (str): Directory where JSON files will be saved.
    """
    # --- Step 1: Read the first sheet of the Excel file ---
    try:
        df = pd.read_excel(excel_path, sheet_name=0)
        # Assumes pandas correctly interprets the cell content as dictionary objects.
        rows_as_dicts = df.to_dict(orient='records')
        print("Excel file read successfully.")
    except Exception as e:
        print(f"Error reading Excel file: {e}")
        return

    # --- Step 2: Read YAML relationships ---
    try:
        with open(yaml_path, 'r') as stream:
            relationships_data = yaml.safe_load(stream)
            relationships_list = relationships_data['Table Relationships']
        print("YAML file read successfully.")
    except Exception as e:
        print(f"Error reading YAML file: {e}")
        return

    # --- Step 3: Organize relationships by table name ---
    relationships_by_table = defaultdict(list)
    for rel in relationships_list:
        from_table_full = rel['from_table']
        table_name_only = from_table_full.split('.')[-1]
        if table_name_only:
            relationships_by_table[table_name_only].append(rel)

    # --- Step 4: Group all rows by their table name using direct access ---
    tables_dict = defaultdict(list)
    try:
        for row_container in rows_as_dicts:
            # **FIX:** Using direct bracket access as requested.
            row_data = row_container['Row Dictionary']
            table_name = row_data['TABLE NAME']
            
            if table_name and pd.notna(table_name):
                table_name_key = str(table_name).split('.')[-1]
                tables_dict[table_name_key].append(row_data)
            else:
                print(f"Warning: Skipping a row because 'TABLE NAME' is empty. Row content: {row_container}")
    except KeyError as e:
        print(f"A required key is missing: {e}. Please check your Excel file's structure and column names.")
        return


    # --- Step 5: Create a simplified JSON schema for each table ---
    try:
        for table_name, columns_rows in tables_dict.items():
            original_full_name = columns_rows[0]['TABLE NAME']
            sanitized_file_name = original_full_name.replace('.', '_')

            columns = []
            for row in columns_rows:
                # **FIX:** Using direct bracket access for all fields.
                column_info = {
                    "Name": row['COLUMN NAME'],
                    "Type": row['DATA TYPE OF THE COLUMN'],
                    "Comment": row['COLUMN DESCRIPTION'],
                    "Parameters": {
                        "unique_values": row['UNIQUE VALUES IN THE COLUMN'],
                        "usage": row['USAGE OF THE COLUMN']
                    }
                }
                columns.append(column_info)

            table_relationships = relationships_by_table[table_name]

            schema = {
                "Name": sanitized_file_name,
                "Description": f"{sanitized_file_name} table derived from Excel data dictionary",
                "Columns": columns,
                "Parameters": {
                    "relationships": table_relationships
                }
            }

            # --- Step 6: Write the generated JSON to a file ---
            output_path = os.path.join(output_directory, f"{sanitized_file_name}.json")
            with open(output_path, 'w') as f:
                json.dump(schema, f, indent=4)
            print(f"Created JSON schema for {original_full_name} at {output_path}")

    except KeyError as e:
        print(f"A required column name is missing from the 'Row Dictionary': {e}. Please check your Excel data.")
        return
    except IOError as e:
        print(f"Could not write file: {e}")


# --- Example Usage ---
excel_file = 'data_dictionary.xlsx'
yaml_file = 'relationships.yaml'
output_dir = 'output'

os.makedirs(output_dir, exist_ok=True)
create_json_schema_from_excel(excel_file, yaml_file, output_dir)


 {
  "Name": "vehicle_sales",
  "Description": "vehicle_sales table derived from Excel data dictionary",
  
  "StorageDescriptor": {
    "Columns": [
      {
        "Name": "id",             // Remove "(PK)" â€” keep names simple
        "Type": "int",
        "Comment": "Unique identifier for each vehicle sale record.",
        "Parameters": {
          "unique_values": "e.g., 6286220,6286224",
          "usage": "System-generated primary key..."
        }
      },
      {
        "Name": "location_id",
        "Type": "int",
        "Comment": "Identifier for the location where the sale occurred.",
        "Parameters": {
          "unique_values": "e.g., 1, 11, 2080",
          "usage": "Represents dealership location..."
        }
      }
      // ... add other columns similarly ...
    ],

    // Required: Even for columns-only metadata, you must include a StorageDescriptor with minimally SerDeInfo
    "SerdeInfo": {
      "SerializationLibrary": "org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe",
      "Parameters": {
        "serialization.format": "1"
      }
    }
  },

  // Table-level parameters for metadata like relationships:
  "Parameters": {
    "relationships": "{\"relationships\":[{\"relationship_name\":\"vehicle_sales_to_inventory\",\"description\":\"Vehicle sales are matched with inventory records via location ID.\",\"from_table\":\"analytics.vehicle_sales\",\"from_column\":\"location_id\",\"to_table\":\"analytics.inventory\",\"to_column\":\"location_id\",\"relationship_type\":\"one-to-one\"}]}"
  }
}

