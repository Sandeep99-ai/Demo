8.Table Relationships:
  - relationship_name: dps_settings_to_excluded_makes
    description: Each DPS setting may exclude specific conquest makes for the same location.
    from_table: cotillion_admin.dps_settings
    from_column: location_id
    to_table: cotillion_admin.dps_location_excluded_conquest_makes
    to_column: location_id_fk
    relationship_type: one-to-many

  - relationship_name: dps_settings_to_map_areas
    description: Each DPS setting may be associated with multiple map areas for the same location.
    from_table: cotillion_admin.dps_settings
    from_column: location_id
    to_table: cotillion_admin.dps_map_areas
    to_column: location_id
    relationship_type: one-to-many
  - relationship_name: dps_settings_to_location_makes
    description: Each DPS setting may be associated with multiple location makes for the same location.
    from_table: cotillion_admin.dps_settings
    from_column: location_id
    to_table: cotillion_admin.location_makes
    to_column: location_id_fk
    relationship_type: one-to-many

  - relationship_name: crm_contact_to_entity_type
    description: Each CRM contact is associated with a single entity type.
    from_table: cotillion_crm.crm_entities_contacts
    from_column: entity_type_id_fk
    to_table: cotillion_admin.sys_entity_types
    to_column: entity_type_id_pk
    relationship_type: many-to-one

  - relationship_name: channel_preferences_to_mosaic_definitions
    description: Channel preferences are linked to mosaic definitions via household ID.
    from_table: analytics.experian_mosaic_channel_preferences
    from_column: household_id
    to_table: analytics.experian_mosaic_definitions
    to_column: household_id
    relationship_type: one-to-one

  - relationship_name: channel_preferences_to_mosaic_attributes
    description: Channel preferences are linked to mosaic attributes via household ID.
    from_table: analytics.experian_mosaic_channel_preferences
    from_column: household_id
    to_table: analytics.experian_mosaic_attributes
    to_column: household_id
    relationship_type: one-to-one

  - relationship_name: message_attributes_to_extended_attributes
    description: Message attributes are linked to extended message attributes via message ID.
    from_table: analytics.experian_message_attributes
    from_column: message_id
    to_table: analytics.experian_extended_message_attributes
    to_column: message_id
    relationship_type: one-to-many

  - relationship_name: messages_to_extended_attributes
    description: Messages are linked to extended message attributes via message ID.
    from_table: analytics.experian_messages
    from_column: id
    to_table: analytics.experian_extended_message_attributes
    to_column: message_id
    relationship_type: one-to-many

  - relationship_name: messages_to_message_attributes
    description: Messages are linked to message attributes via message ID.
    from_table: analytics.experian_messages
    from_column: id
    to_table: analytics.experian_message_attributes
    to_column: message_id
    relationship_type: one-to-many

  - relationship_name: mosaic_definitions_to_extended_attributes
    description: Mosaic definitions are linked to extended message attributes via mosaic code.
    from_table: analytics.experian_mosaic_definitions
    from_column: code
    to_table: analytics.experian_extended_message_attributes
    to_column: mosaic_code
    relationship_type: one-to-many

  - relationship_name: mosaic_definitions_to_channel_preferences
    description: Mosaic definitions are linked to channel preferences via mosaic code.
    from_table: analytics.experian_mosaic_definitions
    from_column: code
    to_table: analytics.experian_mosaic_channel_preferences
    to_column: mosaic_code
    relationship_type: one-to-many

  - relationship_name: vehicle_sales_to_inventory
    description: Vehicle sales are matched with inventory records via location ID.
    from_table: analytics.vehicle_sales
    from_column: location_id
    to_table: analytics.inventory
    to_column: location_id
    relationship_type: one-to-one



import pandas as pd
import json
import yaml
from collections import defaultdict
import os

def create_json_schema_from_excel(excel_path, yaml_path, output_directory):
    """
    Parses an Excel data dictionary where row data is nested under a 'Row Dictionary' key.
    It combines this with a YAML file of table relationships to create simplified JSON schemas.

    Args:
        excel_path (str): Path to the Excel workbook.
        yaml_path (str): Path to the YAML file containing relationships.
        output_directory (str): Directory where JSON files will be saved.
    """
    # --- Step 1: Read the first sheet of the Excel file ---
    try:
        df = pd.read_excel(excel_path, sheet_name=0)
        # This structure assumes the primary column is named 'Row Dictionary'
        # and its content is a string representation of a dictionary.
        # We will need to parse it.
        # If pandas reads it directly as objects, this is simpler.
        # For now, let's assume it's structured correctly upon reading.
        rows_as_dicts = df.to_dict(orient='records')
        print("Excel file read successfully.")
    except Exception as e:
        print(f"Error reading Excel file: {e}")
        return

    # --- Step 2: Read YAML relationships ---
    try:
        with open(yaml_path, 'r') as stream:
            relationships_data = yaml.safe_load(stream)
            relationships_list = relationships_data.get('Table Relationships', [])
        print("YAML file read successfully.")
    except Exception as e:
        print(f"Error reading YAML file: {e}")
        return

    # --- Step 3: Organize relationships by table name ---
    relationships_by_table = defaultdict(list)
    for rel in relationships_list:
        from_table_full = rel.get('from_table', '')
        table_name_only = from_table_full.split('.')[-1]
        if table_name_only:
            relationships_by_table[table_name_only].append(rel)

    # --- Step 4: Group all rows by their table name, looking inside 'Row Dictionary' ---
    tables_dict = defaultdict(list)
    for row_container in rows_as_dicts:
        # **FIX:** Access the nested dictionary with the key 'Row Dictionary'.
        row_data = row_container.get('Row Dictionary', {})

        # Now get the table name from within the nested dictionary.
        table_name = row_data.get('TABLE NAME')
        if table_name and pd.notna(table_name):
            table_name_key = str(table_name).split('.')[-1]
            # We append the inner dictionary, which has all the column info.
            tables_dict[table_name_key].append(row_data)
        else:
            print(f"Warning: Skipping a row because 'TABLE NAME' was not found inside 'Row Dictionary'. Row content: {row_container}")

    # --- Step 5: Create a simplified JSON schema for each table ---
    for table_name, columns_rows in tables_dict.items():
        original_full_name = columns_rows[0].get('TABLE NAME', table_name)
        sanitized_file_name = original_full_name.replace('.', '_')

        columns = []
        for row in columns_rows:
            # **FIX:** Access all column data from the nested dictionary.
            column_info = {
                "Name": row.get('COLUMN NAME', ''),
                "Type": row.get('DATA TYPE OF THE COLUMN', 'string'),
                "Comment": row.get('COLUMN DESCRIPTION', ''),
                "Parameters": {
                    "unique_values": row.get('UNIQUE VALUES IN THE COLUMN', 'N/A'),
                    "usage": row.get('USAGE OF THE COLUMN', '')
                }
            }
            columns.append(column_info)

        table_relationships = relationships_by_table.get(table_name, [])

        schema = {
            "Name": sanitized_file_name,
            "Description": f"{sanitized_file_name} table derived from Excel data dictionary",
            "Columns": columns,
            "Parameters": {
                "relationships": table_relationships
            }
        }

        # --- Step 6: Write the generated JSON to a file ---
        output_path = os.path.join(output_directory, f"{sanitized_file_name}.json")
        try:
            with open(output_path, 'w') as f:
                json.dump(schema, f, indent=4)
            print(f"Created JSON schema for {original_full_name} at {output_path}")
        except IOError as e:
            print(f"Could not write file {output_path}: {e}")


# --- Example Usage ---
excel_file = 'data_dictionary.xlsx'
yaml_file = 'relationships.yaml'
output_dir = 'output'

os.makedirs(output_dir, exist_ok=True)
create_json_schema_from_excel(excel_file, yaml_file, output_dir)
