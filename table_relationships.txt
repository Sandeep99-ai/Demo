8.Table Relationships:
  - relationship_name: dps_settings_to_excluded_makes
    description: Each DPS setting may exclude specific conquest makes for the same location.
    from_table: cotillion_admin.dps_settings
    from_column: location_id
    to_table: cotillion_admin.dps_location_excluded_conquest_makes
    to_column: location_id_fk
    relationship_type: one-to-many

  - relationship_name: dps_settings_to_map_areas
    description: Each DPS setting may be associated with multiple map areas for the same location.
    from_table: cotillion_admin.dps_settings
    from_column: location_id
    to_table: cotillion_admin.dps_map_areas
    to_column: location_id
    relationship_type: one-to-many
  - relationship_name: dps_settings_to_location_makes
    description: Each DPS setting may be associated with multiple location makes for the same location.
    from_table: cotillion_admin.dps_settings
    from_column: location_id
    to_table: cotillion_admin.location_makes
    to_column: location_id_fk
    relationship_type: one-to-many

  - relationship_name: crm_contact_to_entity_type
    description: Each CRM contact is associated with a single entity type.
    from_table: cotillion_crm.crm_entities_contacts
    from_column: entity_type_id_fk
    to_table: cotillion_admin.sys_entity_types
    to_column: entity_type_id_pk
    relationship_type: many-to-one

  - relationship_name: channel_preferences_to_mosaic_definitions
    description: Channel preferences are linked to mosaic definitions via household ID.
    from_table: analytics.experian_mosaic_channel_preferences
    from_column: household_id
    to_table: analytics.experian_mosaic_definitions
    to_column: household_id
    relationship_type: one-to-one

  - relationship_name: channel_preferences_to_mosaic_attributes
    description: Channel preferences are linked to mosaic attributes via household ID.
    from_table: analytics.experian_mosaic_channel_preferences
    from_column: household_id
    to_table: analytics.experian_mosaic_attributes
    to_column: household_id
    relationship_type: one-to-one

  - relationship_name: message_attributes_to_extended_attributes
    description: Message attributes are linked to extended message attributes via message ID.
    from_table: analytics.experian_message_attributes
    from_column: message_id
    to_table: analytics.experian_extended_message_attributes
    to_column: message_id
    relationship_type: one-to-many

  - relationship_name: messages_to_extended_attributes
    description: Messages are linked to extended message attributes via message ID.
    from_table: analytics.experian_messages
    from_column: id
    to_table: analytics.experian_extended_message_attributes
    to_column: message_id
    relationship_type: one-to-many

  - relationship_name: messages_to_message_attributes
    description: Messages are linked to message attributes via message ID.
    from_table: analytics.experian_messages
    from_column: id
    to_table: analytics.experian_message_attributes
    to_column: message_id
    relationship_type: one-to-many

  - relationship_name: mosaic_definitions_to_extended_attributes
    description: Mosaic definitions are linked to extended message attributes via mosaic code.
    from_table: analytics.experian_mosaic_definitions
    from_column: code
    to_table: analytics.experian_extended_message_attributes
    to_column: mosaic_code
    relationship_type: one-to-many

  - relationship_name: mosaic_definitions_to_channel_preferences
    description: Mosaic definitions are linked to channel preferences via mosaic code.
    from_table: analytics.experian_mosaic_definitions
    from_column: code
    to_table: analytics.experian_mosaic_channel_preferences
    to_column: mosaic_code
    relationship_type: one-to-many

  - relationship_name: vehicle_sales_to_inventory
    description: Vehicle sales are matched with inventory records via location ID.
    from_table: analytics.vehicle_sales
    from_column: location_id
    to_table: analytics.inventory
    to_column: location_id
    relationship_type: one-to-one





import pandas as pd
import json
import yaml
from collections import defaultdict
import os

def create_json_schema_from_excel(excel_path, yaml_path, output_directory):
    """
    Parses the first sheet of an Excel data dictionary and a YAML file with table relationships
    to create simplified JSON schema files for each table.

    Args:
        excel_path (str): Path to the Excel workbook.
        yaml_path (str): Path to the YAML file containing relationships.
        output_directory (str): Directory where JSON files will be saved.
    """
    # --- Step 1: Read first sheet of Excel and skip the first row ---
    try:
        df = pd.read_excel(excel_path, sheet_name=0)
        df = df.iloc[1:]  # Skip the first row
        rows_as_dicts = df.to_dict(orient='records')
        print("Excel file read successfully. Processing rows from second row onward.")
    except Exception as e:
        print(f"Error reading Excel file: {e}")
        return

    # --- Step 2: Read YAML relationships ---
    try:
        with open(yaml_path, 'r') as stream:
            relationships_data = yaml.safe_load(stream)
            relationships_list = relationships_data.get('Table Relationships', [])
        print("YAML file read successfully.")
    except Exception as e:
        print(f"Error reading YAML file: {e}")
        return

    # --- Step 3: Organize relationships by table ---
    relationships_by_table = defaultdict(list)
    for rel in relationships_list:
        relationships_by_table[rel['from_table']].append(rel)

    # --- Step 4: Organize rows by table ---
    tables_dict = defaultdict(list)
    for row in rows_as_dicts:
        table_name = row['TABLE NAME']
        tables_dict[table_name].append(row)

    # --- Step 5: Create simplified JSON schema for each table ---
    for table_name, columns_rows in tables_dict.items():
        sanitized_table_name = table_name.replace('.', '_')

        columns = []
        for row in columns_rows:
            column_info = {
                "Name": row['COLUMN NAME'],
                "Type": row['DATA TYPE OF THE COLUMN'],
                "Comment": row['COLUMN DESCRIPTION'],
                "Parameters": {
                    "unique_values": row['UNIQUE VALUES IN THE COLUMN'],
                    "usage": row['USAGE OF THE COLUMN']
                }
            }
            columns.append(column_info)

        table_relationships = relationships_by_table.get(table_name, [])

        # --- Simplified schema ---
        schema = {
            "Name": sanitized_table_name,
            "Description": f"{sanitized_table_name} table derived from Excel data dictionary",
            "Columns": columns,
            "Parameters": {
                "relationships": table_relationships if table_relationships else []
            }
        }

        # --- Step 6: Write JSON to file ---
        output_path = os.path.join(output_directory, f"{sanitized_table_name}.json")
        try:
            with open(output_path, 'w') as f:
                json.dump(schema, f, indent=4)
            print(f"Created JSON schema for {table_name} at {output_path}")
        except IOError as e:
            print(f"Could not write file {output_path}: {e}")


# --- Example Usage ---
excel_file = 'data_dictionary.xlsx'
yaml_file = 'relationships.yaml'
output_dir = 'output'

os.makedirs(output_dir, exist_ok=True)
create_json_schema_from_excel(excel_file, yaml_file, output_dir)
