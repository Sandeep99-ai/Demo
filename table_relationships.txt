8.Table Relationships:
  - relationship_name: dps_settings_to_excluded_makes
    description: Each DPS setting may exclude specific conquest makes for the same location.
    from_table: cotillion_admin.dps_settings
    from_column: location_id
    to_table: cotillion_admin.dps_location_excluded_conquest_makes
    to_column: location_id_fk
    relationship_type: one-to-many

  - relationship_name: dps_settings_to_map_areas
    description: Each DPS setting may be associated with multiple map areas for the same location.
    from_table: cotillion_admin.dps_settings
    from_column: location_id
    to_table: cotillion_admin.dps_map_areas
    to_column: location_id
    relationship_type: one-to-many
  - relationship_name: dps_settings_to_location_makes
    description: Each DPS setting may be associated with multiple location makes for the same location.
    from_table: cotillion_admin.dps_settings
    from_column: location_id
    to_table: cotillion_admin.location_makes
    to_column: location_id_fk
    relationship_type: one-to-many

  - relationship_name: crm_contact_to_entity_type
    description: Each CRM contact is associated with a single entity type.
    from_table: cotillion_crm.crm_entities_contacts
    from_column: entity_type_id_fk
    to_table: cotillion_admin.sys_entity_types
    to_column: entity_type_id_pk
    relationship_type: many-to-one

  - relationship_name: channel_preferences_to_mosaic_definitions
    description: Channel preferences are linked to mosaic definitions via household ID.
    from_table: analytics.experian_mosaic_channel_preferences
    from_column: household_id
    to_table: analytics.experian_mosaic_definitions
    to_column: household_id
    relationship_type: one-to-one

  - relationship_name: channel_preferences_to_mosaic_attributes
    description: Channel preferences are linked to mosaic attributes via household ID.
    from_table: analytics.experian_mosaic_channel_preferences
    from_column: household_id
    to_table: analytics.experian_mosaic_attributes
    to_column: household_id
    relationship_type: one-to-one

  - relationship_name: message_attributes_to_extended_attributes
    description: Message attributes are linked to extended message attributes via message ID.
    from_table: analytics.experian_message_attributes
    from_column: message_id
    to_table: analytics.experian_extended_message_attributes
    to_column: message_id
    relationship_type: one-to-many

  - relationship_name: messages_to_extended_attributes
    description: Messages are linked to extended message attributes via message ID.
    from_table: analytics.experian_messages
    from_column: id
    to_table: analytics.experian_extended_message_attributes
    to_column: message_id
    relationship_type: one-to-many

  - relationship_name: messages_to_message_attributes
    description: Messages are linked to message attributes via message ID.
    from_table: analytics.experian_messages
    from_column: id
    to_table: analytics.experian_message_attributes
    to_column: message_id
    relationship_type: one-to-many

  - relationship_name: mosaic_definitions_to_extended_attributes
    description: Mosaic definitions are linked to extended message attributes via mosaic code.
    from_table: analytics.experian_mosaic_definitions
    from_column: code
    to_table: analytics.experian_extended_message_attributes
    to_column: mosaic_code
    relationship_type: one-to-many

  - relationship_name: mosaic_definitions_to_channel_preferences
    description: Mosaic definitions are linked to channel preferences via mosaic code.
    from_table: analytics.experian_mosaic_definitions
    from_column: code
    to_table: analytics.experian_mosaic_channel_preferences
    to_column: mosaic_code
    relationship_type: one-to-many

  - relationship_name: vehicle_sales_to_inventory
    description: Vehicle sales are matched with inventory records via location ID.
    from_table: analytics.vehicle_sales
    from_column: location_id
    to_table: analytics.inventory
    to_column: location_id
    relationship_type: one-to-one



import pandas as pd
import json
import yaml
from collections import defaultdict
import os

def create_json_schema_from_excel(excel_path, yaml_path, output_directory):
    """
    Parses the first sheet of an Excel data dictionary and a YAML file with table relationships
    to create simplified JSON schema files for each table. It correctly handles 'schema.table'
    naming conventions in the relationships file.

    Args:
        excel_path (str): Path to the Excel workbook.
        yaml_path (str): Path to the YAML file containing relationships.
        output_directory (str): Directory where JSON files will be saved.
    """
    # --- Step 1: Read the first sheet of the Excel file ---
    try:
        # Reading the first sheet. Assuming the first row contains headers.
        df = pd.read_excel(excel_path, sheet_name=0)
        # Convert all rows to a list of dictionaries for easier processing
        rows_as_dicts = df.to_dict(orient='records')
        print("Excel file read successfully.")
    except Exception as e:
        print(f"Error reading Excel file: {e}")
        return

    # --- Step 2: Read YAML relationships ---
    try:
        with open(yaml_path, 'r') as stream:
            relationships_data = yaml.safe_load(stream)
            # Safely get the list of relationships
            relationships_list = relationships_data.get('Table Relationships', [])
        print("YAML file read successfully.")
    except Exception as e:
        print(f"Error reading YAML file: {e}")
        return

    # --- Step 3: Organize relationships by table name (handling 'schema.table' format) ---
    relationships_by_table = defaultdict(list)
    for rel in relationships_list:
        from_table_full = rel.get('from_table', '')
        # Split 'schema.table' and use only the table name as the key
        table_name_only = from_table_full.split('.')[-1]
        if table_name_only: # Ensure we have a valid name after splitting
            relationships_by_table[table_name_only].append(rel)

    # --- Step 4: Group all rows from the Excel sheet by their table name ---
    tables_dict = defaultdict(list)
    for row in rows_as_dicts:
        # Ensure the 'TABLE NAME' key exists and is not empty
        if 'TABLE NAME' in row and pd.notna(row['TABLE NAME']):
            table_name = row['TABLE NAME']
            # Also handle cases where the Excel file might have schema.table format
            table_name_key = table_name.split('.')[-1]
            tables_dict[table_name_key].append(row)

    # --- Step 5: Create a simplified JSON schema for each table ---
    for table_name, columns_rows in tables_dict.items():
        # Sanitize the original full table name for use in the file system and description
        original_full_name = columns_rows[0]['TABLE NAME']
        sanitized_file_name = original_full_name.replace('.', '_')

        columns = []
        for row in columns_rows:
            # Check for NaN values and replace with empty strings or defaults
            column_info = {
                "Name": row.get('COLUMN NAME', ''),
                "Type": row.get('DATA TYPE OF THE COLUMN', 'string'),
                "Comment": row.get('COLUMN DESCRIPTION', ''),
                "Parameters": {
                    "unique_values": row.get('UNIQUE VALUES IN THE COLUMN', 'N/A'),
                    "usage": row.get('USAGE OF THE COLUMN', '')
                }
            }
            columns.append(column_info)

        # Match the extracted table name with our relationship dictionary
        table_relationships = relationships_by_table.get(table_name, [])

        # --- Simplified schema structure ---
        schema = {
            "Name": sanitized_file_name,
            "Description": f"{sanitized_file_name} table derived from Excel data dictionary",
            "Columns": columns,
            "Parameters": {
                "relationships": table_relationships # Directly embed the list
            }
        }

        # --- Step 6: Write the generated JSON to a file ---
        output_path = os.path.join(output_directory, f"{sanitized_file_name}.json")
        try:
            with open(output_path, 'w') as f:
                json.dump(schema, f, indent=4)
            print(f"Created JSON schema for {original_full_name} at {output_path}")
        except IOError as e:
            print(f"Could not write file {output_path}: {e}")


# --- Example Usage ---
# Assumes 'data_dictionary.xlsx' and 'relationships.yaml' are in the same directory.
excel_file = 'data_dictionary.xlsx'
yaml_file = 'relationships.yaml'
output_dir = 'output'

# Create the output directory if it doesn't already exist
os.makedirs(output_dir, exist_ok=True)

create_json_schema_from_excel(excel_file, yaml_file, output_dir)

