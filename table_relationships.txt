8.Table Relationships:
  - relationship_name: dps_settings_to_excluded_makes
    description: Each DPS setting may exclude specific conquest makes for the same location.
    from_table: cotillion_admin.dps_settings
    from_column: location_id
    to_table: cotillion_admin.dps_location_excluded_conquest_makes
    to_column: location_id_fk
    relationship_type: one-to-many

  - relationship_name: dps_settings_to_map_areas
    description: Each DPS setting may be associated with multiple map areas for the same location.
    from_table: cotillion_admin.dps_settings
    from_column: location_id
    to_table: cotillion_admin.dps_map_areas
    to_column: location_id
    relationship_type: one-to-many
  - relationship_name: dps_settings_to_location_makes
    description: Each DPS setting may be associated with multiple location makes for the same location.
    from_table: cotillion_admin.dps_settings
    from_column: location_id
    to_table: cotillion_admin.location_makes
    to_column: location_id_fk
    relationship_type: one-to-many

  - relationship_name: crm_contact_to_entity_type
    description: Each CRM contact is associated with a single entity type.
    from_table: cotillion_crm.crm_entities_contacts
    from_column: entity_type_id_fk
    to_table: cotillion_admin.sys_entity_types
    to_column: entity_type_id_pk
    relationship_type: many-to-one

  - relationship_name: channel_preferences_to_mosaic_definitions
    description: Channel preferences are linked to mosaic definitions via household ID.
    from_table: analytics.experian_mosaic_channel_preferences
    from_column: household_id
    to_table: analytics.experian_mosaic_definitions
    to_column: household_id
    relationship_type: one-to-one

  - relationship_name: channel_preferences_to_mosaic_attributes
    description: Channel preferences are linked to mosaic attributes via household ID.
    from_table: analytics.experian_mosaic_channel_preferences
    from_column: household_id
    to_table: analytics.experian_mosaic_attributes
    to_column: household_id
    relationship_type: one-to-one

  - relationship_name: message_attributes_to_extended_attributes
    description: Message attributes are linked to extended message attributes via message ID.
    from_table: analytics.experian_message_attributes
    from_column: message_id
    to_table: analytics.experian_extended_message_attributes
    to_column: message_id
    relationship_type: one-to-many

  - relationship_name: messages_to_extended_attributes
    description: Messages are linked to extended message attributes via message ID.
    from_table: analytics.experian_messages
    from_column: id
    to_table: analytics.experian_extended_message_attributes
    to_column: message_id
    relationship_type: one-to-many

  - relationship_name: messages_to_message_attributes
    description: Messages are linked to message attributes via message ID.
    from_table: analytics.experian_messages
    from_column: id
    to_table: analytics.experian_message_attributes
    to_column: message_id
    relationship_type: one-to-many

  - relationship_name: mosaic_definitions_to_extended_attributes
    description: Mosaic definitions are linked to extended message attributes via mosaic code.
    from_table: analytics.experian_mosaic_definitions
    from_column: code
    to_table: analytics.experian_extended_message_attributes
    to_column: mosaic_code
    relationship_type: one-to-many

  - relationship_name: mosaic_definitions_to_channel_preferences
    description: Mosaic definitions are linked to channel preferences via mosaic code.
    from_table: analytics.experian_mosaic_definitions
    from_column: code
    to_table: analytics.experian_mosaic_channel_preferences
    to_column: mosaic_code
    relationship_type: one-to-many

  - relationship_name: vehicle_sales_to_inventory
    description: Vehicle sales are matched with inventory records via location ID.
    from_table: analytics.vehicle_sales
    from_column: location_id
    to_table: analytics.inventory
    to_column: location_id
    relationship_type: one-to-one




import pandas as pd
import json
import yaml
from collections import defaultdict

def create_json_schema_from_excel(excel_path, yaml_path, output_directory):
    """
    Parses an Excel data dictionary and a YAML file with table relationships
    to create JSON schema files for each table.

    Args:
        excel_path (str): The file path for the Excel workbook.
        yaml_path (str): The file path for the YAML file containing relationships.
        output_directory (str): The directory where the JSON files will be saved.
    """
    try:
        # Read the first sheet of the Excel file
        df = pd.read_excel(excel_path, sheet_name=0)
        print("Successfully read the Excel file.")
    except FileNotFoundError:
        print(f"Error: The file at {excel_path} was not found.")
        return
    except Exception as e:
        print(f"An error occurred while reading the Excel file: {e}")
        return

    try:
        # Read and parse the YAML file for relationships
        with open(yaml_path, 'r') as stream:
            relationships_data = yaml.safe_load(stream)
            # The user provided the relationships under a key, so we extract the list
            relationships_list = relationships_data.get('Table Relationships', [])
        print("Successfully read and parsed the YAML file.")
    except FileNotFoundError:
        print(f"Error: The file at {yaml_path} was not found.")
        return
    except yaml.YAMLError as exc:
        print(f"Error parsing YAML file: {exc}")
        return
    except Exception as e:
        print(f"An error occurred while reading the YAML file: {e}")
        return


    # Organize relationships by the 'from_table'
    relationships_by_table = defaultdict(list)
    for rel in relationships_list:
        relationships_by_table[rel['from_table']].append(rel)

    # Group the dataframe by table name
    tables = df.groupby('TABLE NAME')

    # Process each table
    for table_name, group in tables:
        # Sanitize table name for file naming
        sanitized_table_name = table_name.replace('.', '_')

        columns = []
        for _, row in group.iterrows():
            column_info = {
                "Name": row['COLUMN NAME'],
                "Type": row['DATA TYPE OF THE COLUMN'],
                "Comment": row['COLUMN DESCRIPTION'],
                "Parameters": {
                    "unique_values": row['UNIQUE VALUES IN THE COLUMN'],
                    "usage": row['USAGE OF THE COLUMN']
                }
            }
            columns.append(column_info)

        table_relationships = relationships_by_table.get(table_name, [])

        schema = {
            "Name": sanitized_table_name,
            "Description": f"{sanitized_table_name} table derived from Excel data dictionary",
            "StorageDescriptor": {
                "Columns": columns,
                "Location": f"s3://your-bucket/{sanitized_table_name}/",
                "InputFormat": "org.apache.hadoop.mapred.TextInputFormat",
                "OutputFormat": "org.apache.hadoop.hive.ql.io.HiveIgnoreKeyTextOutputFormat",
                "SerdeInfo": {
                    "SerializationLibrary": "org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe",
                    "Parameters": {"serialization.format": "1"}
                }
            },
            "PartitionKeys": [],
            "TableType": "EXTERNAL_TABLE",
            "Parameters": {
                "relationships": json.dumps({"relationships": table_relationships}) if table_relationships else "{}"
            }
        }

        # Write the JSON schema to a file
        output_path = f"{output_directory}/{sanitized_table_name}.json"
        try:
            with open(output_path, 'w') as f:
                json.dump(schema, f, indent=4)
            print(f"Successfully created JSON schema for {table_name} at {output_path}")
        except IOError as e:
            print(f"Could not write to file {output_path}. Error: {e}")


if __name__ == '__main__':
    # --- Instructions ---
    # 1. Save your Excel data dictionary as 'data_dictionary.xlsx'
    #    in the same directory as this script.
    #    Ensure the columns are named: 'TABLE NAME', 'COLUMN NAME',
    #    'DATA TYPE OF THE COLUMN', 'COLUMN DESCRIPTION',
    #    'UNIQUE VALUES IN THE COLUMN', 'USAGE OF THE COLUMN'
    # 2. Save your YAML relationships as 'relationships.yaml' in the same directory.
    #    Make sure the YAML content is properly formatted.
    # 3. Create a directory named 'output' for the generated JSON files.
    # 4. Run the script.

    excel_file = 'data_dictionary.xlsx'
    yaml_file = 'relationships.yaml'
    output_dir = 'output'

    # Create the output directory if it doesn't exist
    import os
    if not os.path.exists(output_dir):
        os.makedirs(output_dir)

    create_json_schema_from_excel(excel_file, yaml_file, output_dir)
